; .gitconfig: git configuration
;
; DELETE UNTRACKED FILES
;
;   git clean -f
;
;   -n
;     Don't actually remove anything, just show what would be done.
;
;   -d
;     Remove untracked directories in addition to untracked files.
;
;   -x
;     Don't use the standard ignore rules read from .gitignore (per directory)
;     and $GIT_DIR/info/exclude.
;
;   -X
;     Remove only files ignored by Git.
;
; RECOVER DELETED COMMITS/BRANCHES
;
;   git reflog
;   # Look for the last commit on the deleted branch.
;   git branch DELETED_BRANCH LAST_COMMIT
;
; SPLIT A COMMIT TO SMALLER COMMITS
;
;   git rebase COMMIT_TO_SPLIT~
;   # Modify `pick` to `edit`.
;   git reset HEAD~
;   git add FILES_FOR_A_COMMIT
;   git commit -m "A commit"
;   git add FILES_FOR_B_COMMIT
;   git commit -m "B commit"
;   git rebase --continue
;
; ==================== BimbaLaszlo (.github.io|gmail.com) ====================

[user]

  name  = "BimbaLaszlo"
  email = "bimbalaszlo@gmail.com"

[alias]

  ; Edit .gitconfig
  # rc = "config --global --edit"
  rc = "!gvim $HOME/.gitconfig &"

  ; Open Git shell on Windows.
  sh = "!cd `[ $GIT_PREFIX ] && echo $GIT_PREFIX || pwd` ; bash --login -i"

  ; __ REMOTE RELATED _____________________

  cl = "clone --recursive"

  ; Push and track the current branch.
  ; See 'push.default'
  ps = "push --set-upstream"

  ; Push and track those remote branches.
  psa = "push --set-upstream --all"

  seto = "remote set-url origin"

  ghcl = "!sh -c 'git clone --recursive https://www.github.com/$*' -"
  ghps = "!sh -c 'git remote set-url origin https://www.github.com/$* ;             \
          git push --all --set-upstream https://www.github.com/$*' -"
  glcl = "!sh -c 'git clone --recursive https://gitlab.com/$*' -"
  glps = "!sh -c 'git remote set-url oigin https://gitlab.com/$* ;              \
          git push --all --set-upstream https://gitlab.com/$*' -"

  ; Use `fetch` instead of `pull`:
  ;
  ; * Detect diverged branches without doing an undesired merge
  ; * Decidable merge/rebase
  ;
  ; If there are no commits added locally, just update the branch pointer:
  ;
  ;   $ git merge --ff
  ;
  ; To rebase on the top of the origin/CURRENT_BRANCH just run
  ;
  ;   $ git rebase
  ;
  ; To merge with it:
  ;
  ;   $ git merge

  f  = "fetch"

  ; __ STATUS _____________________________

  s   = "status --short --branch"
  sb  = "branch-status"
  sba = "branch-status --all"
  sr  = "remote show origin"

  ; __ LOG ________________________________

  ; --all                           Show all branch/tag/remote
  ; --branches, --tags, --remotes   Guess
  ;
  ; See DIFF for additional parameters.
  ;
  ; Look for expression in commit messages.
  ;
  ;   git log --grep'regex'
  ;
  ; Look for the addition/deletion of text - ie. when was the string
  ; firstly introduced or where was it removed.
  ;
  ;   git log -S'string' -- file
  ;
  ; Look for differences whose patch text contains modified lines that
  ; match <regex>.
  ;
  ;   git log -G'regex' -- file
  ;
  ; Shows how the function main() in the file main.c evolved over time.
  ;
  ;   git log -L '/int main/',/^}/:main.c

  l    = "log --graph --date-order --date=short --format=shortlog"
  la   = "log --graph --date-order --date=short --format=shortlog --all"
  las  = "log --graph --date-order --date=short --format=shortlog --all --simplify-by-decoration"
  lg   = "log --graph --date-order"
  lgg  = "log --graph --date-order --name-status"
  lp   = "log --graph --date-order --patch --stat --ignore-blank-lines"
  day  = "log --graph --date-order --name-status --since midnight"
  yday = "log --graph --date-order --name-status --since=day.before.yesterday.midnight --until=midnight"

  ; Show `local...remote` if both side exists.
  lf = "fetch-log"

  ; Formated for mail to my boss.
  ; The last Sed command removes the searchable "bangtag" line.
  mail = "!git log --format=mail $@ | sed '/!TITLE!/! s/.*/  &/; s/!TITLE! //; /^\\s\\+!\\S/{N;d}'; #"

  ; __ SHOW _______________________________

  sw  = "show --patch --stat --ignore-blank-lines"
  sww = "show --patch --stat --ignore-blank-lines --color-words"

  ; __ DIFF _______________________________

  ; -w             Ignore whitespace diffs
  ; --color-words  Show the exact diffs
  ; --diff-filter  Filter files: A|C|D|M|R|T|U|X|B

  df   = "diff --patch --stat --ignore-blank-lines"
  dfc  = "diff --patch --stat --ignore-blank-lines --cached"
  dfw  = "diff --patch --stat --ignore-blank-lines --color-words"
  dfwc = "diff --patch --stat --ignore-blank-lines --color-words --cached"
  dfs  = "diff --name-status"
  gdf  = "difftool"

  ; __ CHECKOUT ___________________________

  co  = "checkout"
  coa = "checkout :/"
  coi = "checkout-index -f"
  coo = "checkout --ours"
  cot = "checkout --theirs"

  ; __ BRANCH _____________________________

  ; Delete remote branch (aka push an empty branch to remote like
  ; LOCAL:REMOTE)
  ;
  ;   git push origin :BRANCH_TO_DELETE

  b = "branch"

  ; __ MERGE ______________________________

  ; Edit merge commit message.
  ;
  ;   git merge -e
  ;
  ; Populate the log message with one-line descriptions from at most <n>
  ; actual commits that are being merged.
  ;
  ;   git merge -e --log
  ;
  ; Check if merge occurs conflicts ("dry run")
  ;
  ;   git merge --no-ff --no-commit
  ;   git merge --abort # If something went wrong
  ;   git commit        # If everything is ok
  ;
  ; Partial merge
  ;
  ;   git merge --no-ff --no-commit BRANCH
  ;   git checkout --ours FILES_TO_DO_NOT_MERGE
  ;   git add FILES
  ;   git commit
  ;
  ; Revert merge
  ;
  ;   git revert -m 1 MERGE_COMMIT
  ;
  ; Resolve a binary merge
  ;
  ;   git checkout --ours   -- <path/to/conflicted_file>
  ;   git checkout --theirs -- <path/to/conflicted_file>
  ;
  ;   where "ours" is the file in the current branch and "theirs" is the file
  ;   from the branch we want to merge.

  me  = "merge"
  mef = "merge --ff-only"
  mea = "merge --abort"

  ; __ BISECT _____________________________

  ; git bisect start HEAD   Start bisecting and mark HEAD as bad
  ; git bisect good/bad     Mark the actual checkout
  ; git bisect good SHA     Mark SHA as good - Git will checkout in the middle of good and bad
  ; git bisect reset        End of bisecting

  bss = "bisect start"
  bsr = "bisect reset" # stop
  bsg = "bisect good"
  bsb = "bisect bad"

  ; __ ADD ________________________________

  ad  = "add --all"
  ada = "add --all :/"

  ; __ COMMIT _____________________________

  c   = "commit"
  ca  = "commit --amend"
  cm  = "commit -m"
  cmu = "commit -m Update"

  ; fixup   merge without changing the commit message
  ; squash  the commit message is editable

  cfu = "commit --fixup"
  csq = "commit --squash"

  ; __ STASH ______________________________

  ; Stash, but keep staged files.
  st  = "stash --keep-index"
  sts = "stash show"
  stp = "stash pop"
  std = "stash drop"

  ; __ REBASE _____________________________
  ; WARNING: `rebase master` means that the current branch is moved to the end
  ; of `master` and `rebase master dev` does the same with `dev` instead of
  ; the current one!

  ; -p  --preserve-merges  Rebase merge commits too
  ;
  ; To rebase a merge commit:
  ;
  ;   git rebase --preserve-merges MERGE_SHA~

  rb  = "rebase"
  rbi = "rebase --interactive"
  rbc = "rebase --continue"
  rba = "rebase --abort"

[core]

  editor = "gvim --nofork"

  ; Do not break long lines (useful for log --graph with a bunch of branches).
  pager = "less -SRF"

  ; Do not modify EOL.
  autocrlf = "false"

  ; Handles very slow the Windows network drives without these settings, but
  ; it require at least 1.9.4.
  ; http://stackoverflow.com/a/24045966
  preloadindex = "true"
  fscache      = "true"

  ; Global .gitignore file.
  excludesfile = "~/.git_template/.global_gitignore"

[color]

  ui = "true"

[init]

  ; Template directory which is copied to .git. For example:
  ; templatedir/hooks -> .git/hooks
  ; http://tbaggery.com/2011/08/08/effortless-ctags-with-git.html
  ; Filenames starting with dot (.hidden) does not copied.
  templatedir = "~/.git_template"

[commit]

  ; Additional text which appears on the top of commit message as a comment.
  template = "~/.git_template/.commit_message"

[log]

  ; Abbreviate SHA to 7 chars.
  abbrevCommit = "true"

  ; 2014-03-25 12:34:56 +0100
  date = "iso"

  ; Track the full history of a file (follows file renames when viewing a
  ; single file's log).
  follow = "true"

  ; Show ref names too (origin/master, tags, etc.).
  decorate = "true"

[pretty]

  shortlog = "%C(auto)%h%C(auto)%d %C(bold blue)%ad %an%n  %s%C(reset)"
  mail     = "!TITLE! * %s%n%+b"

[diff]

  ; Find renamed and copied files.
  renames = "copies"
  tool    = "gvimdiff"

[rebase]

  autoSquash = "true"

[merge]

  ; Allways create (empty) merge commits.
  ff   = "false"
  tool = "gvimdiff"

[fetch]

  ; Allways update all submudolues.
  recurseSubmodules = "true"

  ; Make sure that any branches that were deleted on the remote are also
  ; deleted locally (but won't delete any locally checked-out branches, those
  ; are different from remote-tracking branches).
  prune = "true"

[push]

  ; `git push -u` is enough instead of `git push -u origin my_branch`.
  default = "current"

  ; Push tags.
  followTags = "true"

[gc]

  ; Minimalize the number of objects in the .git dir (speeds up the things a
  ; bit).
  auto = 256
