python.txt: sajat jegyzetek

============= BimbaLaszlo(.co.nr|gmail.com) ============== 2014.05.27 15:51 ==

                          PIP TELEPÍTÉSE WINDOWS-RA                       {{{1
==============================================================================

    Töltsd le ezt a fájlt, majd futtasd:

      https://raw.github.com/pypa/pip/master/contrib/get-pip.py

    Miután feltelepítette magát, add hozzá a 'c:\python\scripts' könyvtárat a
    PATH környezetei változóhoz, hogy a parancssorból elérhesd a pip-et.

    A telepíthető csomagok a következő címen érhetőek el:

      https://pypi.python.org/

    Használatukhoz:

      $ pip install csomag
      $ pip uninstall csomag
      $ pip list

    Néhány közülük:

      flake8  syntax checker

                                ÉRDEMES MEGLESNI                          {{{1
==============================================================================

    __ FREECODE ___________________________

    pycam

      Ablakkezelés és a 3d miatt.

                                    PYDOC                                 {{{1
==============================================================================

    A modulok dokumentációinak elérése:

      python -m pydoc MODUL_NEVE
      python -m pydoc -k KERESENDO_KIFEJEZES

    Böngészőben való megnyitás:

      python -m pydoc -b

                                ALAPVETŐ DOLGOK                           {{{1
==============================================================================

    Ha globális változónak akarunk értéket adni egy függvényből, akkor a
    függvény elején mindenképp egyértelműsítsük, hogy globális változóról van
    szó.

      var = ''

      def func():
        global var
        var = 'foo'

    Változó létezésének ellenőrzése:

      if var in locals()
      if var in globals()

    A sztring része egy változónak?

      if 'eszi' in 'hakapeszimaki'

    Változó törlése:

      del var
      # Globális változónál:
      del globals()['var']

                                PRINT, FORMAT                             {{{2
  ____________________________________________________________________________

    Számérték kiíratásához használj format-ot:

      print( 'X{} Y{} PI{:3f} SZÁM{:{}f} {JELOLO}'.format( \
        12.3456789, round( 98.7654321, 3),                 \
        math.pi,                                           \
        szam_erteke, szam_pontossaga,                      \
        JELOLO = 'hozzárendelt érték'                      \
      )

    Dict, vagy egyéb összetett objektum kiíratása rendezett formában:

      import pprint

      pprint.pprint( dict )
      print( pprint.pformat( dict ) )

                               LIST, DICTIONARY                           {{{2
  ____________________________________________________________________________

    Lista inicializálása:

      l  = []
      l  = [ 1, 'abc' ]
      l += 'uj elem'

    Dictionary:

      d = {}
      d = { 'szam' : 123, 'sztring' : 'abc' }

    Megadott értékű elem törlése listából:

      lista.remove( 'ertek' )

    Key, vagy index szerinti törlés:

      del dict['key']

    Dict key lehet int is.

      d = { 1 : 'valami' }

    OrderedDict utoló elemének key értékéhez való hozzáférés:

      next( reversed( OrderedDict ) )

    A 'copy'-val másolatot készítünk, az értékadással hivatkozást.

      d  = { 'nev' : 'd' }

      dc = d.copy()
      dc['nev'] = 'dc'

      print( 'd: ', d  )
      print( 'dc:', dc )

      de = d
      de['nev'] = 'de'

      print( 'd: ', d  )
      print( 'de:', de )

      __ KIMENET ____________________________

      d:  {'nev': 'd'}
      dc: {'nev': 'dc'}
      d:  {'nev': 'de'}
      de: {'nev': 'de'}

                                INLINE MOTYESZ                            {{{2
  ____________________________________________________________________________

    Inline if expression:

      expression_if_true if condition else expression_if_false

    Inline for-ciklus:

      print( [ 10 * i for i in range( 19 ) ] )

    Dictionary kiíratása:

      ', '.join( i + ' = ' + str( j ) for (i,j) in a.items() )

    Lista azon elemeinek kiíratása megadott kivételekkel:

      [ i for i in LISTA if i != 'KIVETEL' ]

                              ÖTLETES MEGOLDÁSOK                          {{{2
  ____________________________________________________________________________

    Tömb feltöltése, pl. 10 elemű sztring lista:

      lista = [ '' ] * 10

    Lista megfordítása a [::-1]-el lehetséges, [::1] változatlanul írja ki
    azt, tehát a kiírás irányát akár egy változóban is tárolhatjuk:

      print( [ 10 * i for i in range( 19 ) ][::-1] )

      irany = -1
      print( [ 10 * i for i in range( 19 ) ][::irany] )

    Ha egy függvény az argumentumában lévő változót szeretné módosítani, azt
    ezzel a módszerrel nem lehet kivitelezni, mivel érték szerinti átadás
    történik:

      ertek = 123
      uj_ertek = fuggveny( 123 )

    Viszont egy trükkel az érték címét adjuk át a függvénynek, ami az átadott
    lista 0. elemére kell, hogy hivatkozzon önmagán belül:

      uj_ertek = fuggveny( [ ertek ] )

                                  OSZTÁLYOK                              {{{1
==============================================================================

    Ahoz a változóhoz, ami az osztály definíciója alatt van, minden alosztály
    hozzáfér és módosíthatja is (alosztályok összekapcsolásához jó).  Ha self
    szintű változót akarsz használni, de nem akarod, hogy a különböző
    alosztályok módosítsák egymást, akkor az __init__ részbe rakd.

    Ha tudni szeretnénk, hogy a változó, vagy függvény az objektumban
    szerepel-e:

      hasattr( obj, 'var' )

                                MODUL, PACKAGE                            {{{1
==============================================================================

    A 'modulok/almodulok/__init__.py' tartalmazza az '__all__' listát a
    modulok neveivel.

      __all__ = [ 'egyik', 'masik' ]

    Ha a hívó fájlban kiadjuk a 'from pack import *' utasítást, úgy az
    __init__.py-ben deklarált objektumok nem kerülnek a hívó névterébe, csupán
    az __all__-ban taláható modulokat tölti be.

    A package-ben található modul ilyen módon elérheti a saját __init__.py
    fájlját, bár erre biztos van szebb megoldás is:

      pack = __import__( '.'.join( __name__ .split( '.' )[0:-1] ) )

    Modul globális változójának módosításait csak a modul importálásával
    érhetjük el, a from modul import * módon nem. Tehát az kezdeti érték
    elérhető, de ha a változó módosul, akkor az az importban nem jelenik meg.
    Pl.:

      __ MOD1.PY ____________________________

      DICT = {}                                       # create a 'global' var
      def init_dict():
        global DICT                                   # make sure we are not referencing a local reference
        DICT = {'a' : '1', 'b' : 2}                   # reset or reassign variable
        print 'Dict initalized to length:',len(DICT)  # everything looks good

      __ MOD2.PY ____________________________

      from mod1 import DICT, init_dict
      print 'Initial length of dict:',len(DICT)
      init_dict()                                     # initialise the DICT variable
      print 'New length of dict:',len(DICT)

      __ OUTPUT _____________________________

      Initial length of dict: 0
      Dict initalized to length: 2
      New length of dict: 0

      __ MOD2-CORRECTED.PY __________________

      import mod1
      print 'Initial length of dict:',len(mod1.DICT)
      mod1.init_dict()
      print 'New length of dict:',len(mod1.DICT)

      __ OUTPUT _____________________________

      Initial length of dict: 0
      Dict initalized to length: 2
      New length of dict: 2

                        MODULOK DINAMIKUS BETÖLTÉSE                       {{{2
  ____________________________________________________________________________

    Package __init__.py fájljába írd bele:

      import os

      __all__ = [ os.path.splitext( modul )[0]                                                 \
                  for modul in os.listdir( os.path.dirname( os.path.abspath( __file__ ) ) )    \
                  if (modul[0] != '_') and (modul.endswith( '.py' ) or os.path.isdir( modul )) \
                ]

    Ezáltal a '.py' fájlok és az alkönyvtárak listája lesz az __all__ tartalma
    (az utóbbi az egymásba ágyazott csomagok miatt lehet érdekes)

                                    DEBUG                                 {{{1
==============================================================================

    Ha a program hibaüzenettel lép ki, vagy menet közben dob egyet és
    kíváncsiak vagyunk a változók állapotára abban a sorban, akkor:

      python -m pdb hibas_szkript.py

    Miután hibázott, lépjünk ki a szkriptünkből (hacsak nem teszi meg
    magától), majd a következő parancscsal visszatekerhetünk a hibás
    állapothoz:

      pm()

    Így kapunk egy debugger prompt-ot, ahol a megszokott python parancsokat
    használva kereshetjük meg a hiba forrását.

    Ha a szkriptet előre meghatározott ponton akarjuk megszakítani, akkor az
    alábbi megoldásra van szükségünk:

      import pdb

      # Kód ...
      # Ahol figyelni akarjuk a folyamatot:
      pdb.set_trace()

    Ha csak bizonyos körülmények esetén akarjuk vizsgálni az adott részt,
    akkor a fenti hívást csak a megfelelő feltételek mellett hajtsuk végre.
    Alant például a feltétel kielégítése után mindig meg fog állni ezen a
    ponton a debug:

      if elcsesztem or ('DEBUG' in globals()):
        global DEBUG
        DEBUG = True
        pdb.set_trace()

    Ha megszakítás nélkül akarjuk folytatni a program futását, akkor adjuk ki
    a következő parancsot:

      del globals()['DEBUG']

    __ PARANCSOK __________________________

    s   step      Léptetve hajtsa végre a sorokat. (függvényhívásokba is belép)
    r   return    A függvény return pontjáig hajtsa végre az utasításokat.
    n   next      A következő sorig hajtsa végre az utasításokat.
    c   continue  Következő breakpoint-ig ne álljon meg.
    q   quit      Kilépés.

                          TRY-EXCEPT HIBA KIIRATASA                       {{{2
  ____________________________________________________________________________

      import sys

      try:
        valami
      except:
        print( sys.exc_info()[:2] )
        így kiírja a hibát is

      try:
        masik verzio
      except Exception as e:
        print( type( e ), str( e ) )

                  HIBAUZENET KIIRATASA AZ OBJEKTUM NEVEVEL                {{{2
  ____________________________________________________________________________

      print( '{}: {}: hiba'.format( __name__, self.__class__.__name__ ) )

    Vagy rovidebben:

      print( '{}: hiba'.format( self.__class__ ) )

                                LEBEGŐPONTOS HIBÁK                        {{{1
==============================================================================

      round( .1, 3 ) + round( .1, 3 ) + round( .1, 3 ) == .3
      False
      round( .1 + .1 + .1, 3 ) == .3
      True

                              BEÉPÍTETT MODULOK                           {{{1
==============================================================================

                                   RE (REGEX)                             {{{2
  ____________________________________________________________________________

    import re
    inport pprint

    elso_talalat = re.search( 'X(\d+)', 'X1 X2 X3' )
    print( elso_talalat.group( 0 ) )

    minden_talalat = re.findall( 'X(\d+)', 'X1 X2 X3' )
    pprint( minden_talalat )

                                   TIME                                   {{{2
  ____________________________________________________________________________

    import time

    print( time.strftime( '%Y.%m.%d %H:%M' ) )
